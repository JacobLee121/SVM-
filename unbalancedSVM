import numpy as np
import matplotlib.pyplot as plt
from sklearn import svm
#from sklearn.linear_model import SGDClassifier

# we create 40 separable points
rng = np.random.RandomState(0)#参数0用于初始化，整形的参数还可以是0-2**32-1中任意的整数
n_samples_1 = 1000
n_samples_2 = 100
X = np.r_[1.5 * rng.randn(n_samples_1, 2),0.5 * rng.randn(n_samples_2, 2) + [2, 2]]#.r_按行组合
y = [0] * (n_samples_1) + [1] * (n_samples_2)
print (X)
print (y)
print(X.size)
# fit the model and get the separating hyperplane
clf = svm.SVC(kernel='linear', C=1.0)#svc参数设定
clf.fit(X, y)#训练模型X是dataY是label，训练之后模型就可以用来预测了

w = clf.coef_[0]
a = - w[0] / w[1]      #a可以理解为斜率
xx = np.linspace(-5, 5)
yy = a * xx - clf.intercept_[0] / w[1]    #二维坐标下的直线方程
print(clf.coef_)
print(w)
print(clf.intercept_)
print(w[0],w[1],clf.intercept_[0])

# get the separating hyperplane using weighted classes
wclf = svm.SVC(kernel='linear', class_weight={1: 15})#调整第二个类（0是第一个类的权重15）
wclf.fit(X, y)

ww = wclf.coef_[0]
wa = -ww[0] / ww[1]
wyy = wa * xx - wclf.intercept_[0] / ww[1]   #带权重的直线intercept截距 coef_系数

# plot separating hyperplanes and samples
h0 = plt.plot(xx, yy, 'k-', label='no weights')
h1 = plt.plot(xx, wyy, 'k--', label='with weights')
plt.scatter(X[:, 0], X[:, 1], c=y)
plt.legend()

plt.axis('tight')
plt.show()
